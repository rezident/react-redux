---
id: accessing-store
title: Доступ к хранилищу
hide_title: true
sidebar_label: Доступ к хранилищу
---

# Доступ к хранилищу

React Redux предоставляет API-интерфейсы, которые позволяют вашим компонентам отправлять действия и подписываться на обновления данных из хранилища.

В рамках этого React Redux абстрагирует детали того, какое хранилище вы используете, и точные детали того, как обрабатывается это взаимодействие с хранилищем.
При типичном использовании ваши собственные компоненты никогда не должны заботиться об этих деталях и никогда не будут напрямую ссылаться на хранилище.
React Redux также внутренне обрабатывает детали того, как хранилище и состояние распространяются на подключенные компоненты, поэтому по умолчанию это работает так, как ожидалось.
Однако могут быть определенные варианты использования, когда вам может потребоваться настроить, как хранилище и состояние распространяются на подключенные компоненты, или получить доступ к хранилищу напрямую.
Вот несколько примеров того, как это сделать.

## Понимание использования контекста

Внутри React Redux использует [контекстную функцию React](https://reactjs.org/docs/context.html), чтобы сделать хранилище Redux доступным для глубоко вложенных подключенных компонентов.
Начиная с React Redux версии 6, это обычно обрабатывается одним экземпляром объекта контекста по умолчанию, сгенерированным `React.createContext()`, который называется `ReactReduxContext`.

Компонент `<Provider>` в React Redux использует `<ReactReduxContext.Provider>` для помещения хранилища Redux и текущего состояния хранилища в контекст, а `connect` использует `<ReactReduxContext.Consumer>` для чтения этих значений и обработки обновлений.

## Использование хука `useStore`

Хук [`useStore`](../api/hooks.md#useStore) возвращает текущий экземпляр хранилища из значения по умолчанию `ReactReduxContext`. Если вам действительно нужен доступ к хранилищу, это рекомендуемый подход.

## Предоставление настраиваемого контекста

Вместо использования экземпляра контекста по умолчанию из React Redux вы можете предоставить свой собственный экземпляр контекста.

```jsx
<Provider context={MyContext} store={store}>
  <App />
</Provider>
```

Если вы предоставите настраиваемый контекст, React Redux будет использовать этот экземпляр контекста вместо того, который он создает и экспортирует по умолчанию.

После того, как вы предоставили настраиваемый контекст для `<Provider />`, вам нужно будет предоставить этот экземпляр контекста всем вашим подключенным компонентам, которые, как ожидается, будут подключаться к одному и тому же хранилищу:

```js
// Вы можете передать контекст в качестве опции для подключения
export default connect(
  mapState,
  mapDispatch,
  null,
  { context: MyContext }
)(MyComponent)

// или вызовите connect, как обычно, чтобы начать
const ConnectedComponent = connect(
  mapState,
  mapDispatch
)(MyComponent)

// Позже передайте настраиваемый контекст в качестве пропа подключенному компоненту
<ConnectedComponent context={MyContext} />
```

Следующая ошибка времени выполнения возникает, когда React Redux не находит хранилище в искомом контексте. Например:

- Вы предоставили настраиваемый экземпляр контекста для `<Provider />`, но не предоставили тот же экземпляр (или не предоставили любой) для ваших подключенных компонентов.
- Вы предоставили настраиваемый контекст для подключенного компонента, но не предоставили тот же экземпляр (или не предоставили любой) для `<Provider />`.

> Инвариантное нарушение
>
> Не удалось найти "хранилище" в контексте "Connect(MyComponent)". Либо оберните корневой компонент в `<Provider>`, либо передайте настраиваемого поставщика контекста React в `<Provider>` и соответствующего потребителя контекста React в Connect(Todo) в параметрах подключения.

## Несколько хранилищ

[Redux был разработан для использования одного хранилища](https://redux.js.org/api/store#a-note-for-flux-users).
Однако, если вы неизбежно столкнулись с необходимостью использовать несколько хранилищ, начиная с версии 6 вы можете сделать это, предоставив (несколько) настраиваемых контекстов.
Это также обеспечивает естественную изоляцию хранилищ, поскольку они находятся в отдельных экземплярах контекста.

```js
// наивный пример
const ContextA = React.createContext();
const ContextB = React.createContext();

// предполагая, что reducerA и reducerB являются правильными функциями редьюсерами
const storeA = createStore(reducerA);
const storeB = createStore(reducerB);

// предоставить экземпляры контекста поставщику
function App() {
  return (
    <Provider store={storeA} context={ContextA} />
      <Provider store={storeB} context={ContextB}>
        <RootModule />
      </Provider>
    </Provider>
  );
}

// выберите соответствующее хранилище с подключенными компонентами,
// которые вам нужны, чтобы использовать правильный контекст
connect(mapStateA, null, null, { context: ContextA })(MyComponentA)

// Вы также можете передать альтернативный экземпляр контекста напрямую подключенному компоненту.
<ConnectedMyComponentA context={ContextA} />

// возможно объединить в цепочку connect()
// в этом случае MyComponent получит объединенные пропсы из обоих хранилищ
compose(
  connect(mapStateA, null, null, { context: ContextA }),
  connect(mapStateB, null, null, { context: ContextB })
)(MyComponent);
```

## Непосредственное использование `ReactReduxContext`

В редких случаях вам может потребоваться доступ к хранилищу Redux непосредственно в ваших собственных компонентах.
Это может быть сделано путем рендеринга соответствующего потребителя контекста самостоятельно и доступа к полю `store` вне значения контекста.

:::caution

Это **_не_ считается частью общедоступного API React Redux и может выйти из строя без уведомления**.
Мы признаем, что у сообщества есть варианты использования, когда это необходимо, и мы постараемся дать пользователям возможность создавать дополнительные функции поверх React Redux, но наше конкретное использование контекста считается деталью реализации.
Если у вас есть дополнительные варианты использования, которые недостаточно охвачены текущими API, сообщите о проблеме, чтобы обсудить возможные улучшения API.

:::

```jsx
import { ReactReduxContext } from 'react-redux'

// Где-то внутри <Provider>
function MyConnectedComponent() {
  // Доступ к хранилищу через хук `useContext`
  const {store} = useContext(ReactReduxContext)

  // в качестве альтернативы используйте форму рендеринга пропсов контекста
  /*
  return (
    <ReactReduxContext.Consumer>
      {({ store }) => {
        // сделать что-то полезное с хранилищем, например передать его дочернему компоненту,
        // где его можно будет использовать в методах жизненного цикла
      }}
    </ReactReduxContext.Consumer>
  )
  */
}
```

## Дополнительные ресурсы

- CodeSandbox example: [A reading list app with theme using a separate store](https://codesandbox.io/s/92pm9n2kl4), implemented by providing (multiple) custom context(s).
- Related issues:
  - [#1132: Update docs for using a different store key](https://github.com/reduxjs/react-redux/issues/1132)
  - [#1126: `<Provider>` misses state changes that occur between when its constructor runs and when it mounts](https://github.com/reduxjs/react-redux/issues/1126)
