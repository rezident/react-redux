---
id: connect-mapstate
title: 'Connect: извлечение данных с помощью mapStateToProps'
hide_title: true
sidebar_label: 'Connect: извлечение данных с помощью mapStateToProps'
---

# Connect: извлечение данных с помощью `mapStateToProps`

В качестве первого аргумента, переданного в `connect`, `mapStateToProps` используется для выбора части данных из хранилища, которая нужна подключенному компоненту. Его часто для краткости называют просто `mapState`.

- Он вызывается каждый раз при изменении состояния хранилища.
- Он получает все состояние хранилища и должен возвращать объект данных, который нужен этому компоненту.

## Определение `mapStateToProps`

`mapStateToProps` следует определять как функцию:

```js
function mapStateToProps(state, ownProps?)
```

Он должен принимать первый аргумент, называемый `state`, необязательно второй аргумент, называемый `ownProps`, и возвращать простой объект, содержащий данные, которые нужны подключенному компоненту.

Эта функция должна быть передана как первый аргумент в `connect`, и она будет вызываться каждый раз при изменении состояния хранилища Redux. Если вы не хотите подписываться на хранилище, передайте `null` или `undefined` в `connect` вместо `mapStateToProps`.

**Не имеет значения, написана ли функция `mapStateToProps` с использованием ключевого слова `function` (`function mapState(state) { }`) или как стрелочная функция (`const mapState = (state) => { }`)** - в любом случае будет работать одинаково.

### Аргументы

1. **`state`**
2. **`ownProps` (не обязательно)**

#### `state`

Первый аргумент функции `mapStateToProps` - это все состояние хранилища Redux (то же значение, возвращаемое вызовом `store.getState()`). Из-за этого первый аргумент традиционно называется просто `state`. (Хотя вы можете дать аргументу любое имя, какое захотите, называть его `store` было бы неверно - это "значение состояния", а не "экземпляр хранилища".)

Функция `mapStateToProps` всегда должна быть написана с как минимум переданным `state`.

```js
// TodoList.js

function mapStateToProps(state) {
  const { todos } = state
  return { todoList: todos.allIds }
}

export default connect(mapStateToProps)(TodoList)
```

#### `ownProps` (не обязательно)

Вы можете определить функцию с помощью второго аргумента `ownProps`, если вашему компоненту нужны данные из его собственных свойств для извлечения данных из хранилища. Этот аргумент будет содержать все пропсы, переданные компоненту-оболочке, который был сгенерирован при помощи `connect`.

```js
// Todo.js

function mapStateToProps(state, ownProps) {
  const { visibilityFilter } = state
  // ownProps будет выглядеть как { "id" : 123 }
  const { id } = ownProps
  const todo = getTodoById(state, id)

  // компонент получает дополнительно:
  return { todo, visibilityFilter }
}

// Позже в вашем приложении родительский компонент рендерит:
<ConnectedTodo id={123} />
// и ваш компонент получает props.id, props.todo и props.visibilityFilter
```

Вам не нужно включать значения из `ownProps` в объект, возвращаемый из `mapStateToProps`. `connect` автоматически объединит эти разные источники свойств в окончательный набор свойств.

### Возврат

Ваша функция `mapStateToProps` должна возвращать простой объект, содержащий данные, необходимые компоненту:

- Каждое поле в объекте станет пропсом для вашего фактического компонента.
- Значения в полях будут использоваться для определения необходимости повторного рендеринга вашего компонента.

Например:

```js
function mapStateToProps(state) {
  return {
    a: 42,
    todos: state.todos,
    filter: state.visibilityFilter,
  }
}

// компонент получит: props.a, props.todos и props.filter
```

> Примечание: В сложных сценариях, где вам нужно больше контроля над производительностью рендеринга, `mapStateToProps` также может возвращать функцию. В этом случае эта функция будет использоваться в качестве последней `mapStateToProps` для конкретного экземпляра компонента. Это позволяет выполнять мемоизацию для каждого экземпляра. Дополнительные сведения см. в разделе документации [Advanced Usage: Factory Functions](../api/connect.md), а также в [PR #279](https://github.com/reduxjs/react-redux/pull/279) и тесты, которые он добавляет. Большинству приложений это не нужно.

## Рекомендации по использованию

### Позвольте `mapStateToProps` изменить форму данных из хранилища

Функции `mapStateToProps` могут и должны делать гораздо больше, чем просто `return state.someSlice`. **Они несут ответственность за "изменение формы" данных хранилища по мере необходимости для этого компонента.** Это может включать в себя возврат значения в виде определенного имени свойства, объединение фрагментов данных из разных частей дерева состояний и преобразование данных хранилища по-разному.

### Использование функций селектора для извлечения и преобразования данных

Мы настоятельно рекомендуем использовать функции «селектора», чтобы помочь инкапсулировать процесс извлечения значений из определенных мест в дереве состояний. Мемоизированные функции селектора также играют ключевую роль в повышении производительности приложения (см. следующие разделы на этой странице и страницу [Расширенное использование: вычисление производных данных](https://redux.js.org/recipes/computing-dehibited-data) для получения дополнительной информации о том, почему и как использовать селекторы.)

### Функции `mapStateToProps` должны быть быстрыми

Каждый раз при изменении хранилища будут выполняться все функции `mapStateToProps` всех подключенных компонентов. По этой причине ваши функции `mapStateToProps` должны работать как можно быстрее. Это также означает, что медленная функция `mapStateToProps` может стать потенциальным узким местом для вашего приложения.

В рамках идеи «переформирования данных» функциям `mapStateToProps` часто требуется преобразовывать данные различными способами (например, фильтровать массив, отображать массив идентификаторов в соответствующие им объекты или извлекать простые значения JS из объектов Immutable.js). Эти преобразования часто могут быть дорогостоящими как с точки зрения затрат на выполнение преобразования, так и с точки зрения того, будет ли компонент повторно отрисован в результате. Если производительность вызывает беспокойство, убедитесь, что эти преобразования выполняются только в том случае, если входные значения изменились.

### Функции `mapStateToProps` должны быть чистыми и синхронными

Подобно редьюсеру Redux, функция `mapStateToProps` всегда должна быть на 100% чистой и синхронной. Он должен принимать только `state` (и `ownProps`) в качестве аргументов и возвращать данные, необходимые компоненту в качестве свойств, без изменения этих аргументов. Его _не_ следует использовать для запуска асинхронного поведения, такого как вызовы AJAX для выборки данных, и функции не должны объявляться как `async`.

## `mapStateToProps` и производительность

### Возвращаемые значения определяют, отрисовывается ли ваш компонент повторно

React Redux внутренне реализует метод `shouldComponentUpdate`, так что компонент-оболочка повторно рендерится именно тогда, когда данные, необходимые вашему компоненту, были изменены. По умолчанию React Redux решает, является ли содержимое объекта, возвращенного из `mapStateToProps`, различным, используя сравнение `===` (проверка на «поверхностное равенство») в каждом поле возвращаемого объекта. Если какое-либо из полей изменилось, ваш компонент будет повторно отрисован, чтобы он мог получать обновленные значения в качестве свойств. Обратите внимание, что возврат измененного объекта с той же ссылкой является распространенной ошибкой, которая может привести к тому, что ваш компонент не будет повторно отрисован, когда ожидалось.

Подводя итог поведению компонента, заключенного в `connect` с `mapStateToProps` для извлечения данных из хранилища:

|                                       | `(state) => stateProps`            | `(state, ownProps) => stateProps`                                              |
| ------------------------------------- | ---------------------------------- | ------------------------------------------------------------------------------ |
| `mapStateToProps` запускается, когда: | сохраняются изменения `state`      | сохраняются изменения `state` или<br />любое поле `ownProps` отличается        |
| компонент перерисовывается, когда:    | любое поле `stateProps` отличается | любое поле `stateProps` отличается или <br /> любое поле `ownProps` отличается |

### Возвращать ссылки на новые объекты только при необходимости

React Redux выполняет поверхностные сравнения, чтобы увидеть, изменились ли результаты `mapStateToProps`. Легко случайно каждый раз возвращать новые ссылки на объекты или массивы, что может привести к повторной визуализации вашего компонента, даже если данные на самом деле совпадают.

Многие общие операции приводят к созданию новых ссылок на объект или массив:

- Создание новых массивов с помощью `someArray.map()` или `someArray.filter()`
- Объединение массивов с помощью `array.concat`
- Выбор части массива с помощью `array.slice`
- Копирование значений с помощью `Object.assign`
- Копирование значений с помощью оператора спреда `{ ...oldState, ...newData }`

Поместите эти операции в [мемоизированные функции селектора](https://redux.js.org/recipes/computing-dehibited-data#creating-a-memoized-selector), чтобы гарантировать, что они выполняются только при изменении входных значений. Это также гарантирует, что если входные значения _не_ изменились, `mapStateToProps` по-прежнему будет возвращать те же значения результатов, что и раньше, а `connect` может пропустить повторный рендеринг.

### Выполняйте дорогостоящие операции только при изменении данных

Преобразование данных часто может быть дорогостоящим (_и_ обычно приводит к созданию новых ссылок на объекты). Чтобы ваша функция `mapStateToProps` работала как можно быстрее, вам следует повторно запускать эти сложные преобразования только тогда, когда соответствующие данные изменились.

Есть несколько способов подойти к этому:

- Некоторые преобразования могут быть рассчитаны в создателе действий или редьюсере, а преобразованные данные могут храниться в хранилище.
- Преобразования также могут выполняться в методе компонента `render()`.
- Если преобразование действительно необходимо выполнить в функции `mapStateToProps`, мы рекомендуем использовать [мемоизированные функции выбора](https://redux.js.org/recipes/computing-dehibited-data#creating-a-memoized-selector), чтобы преобразование запускалось только при изменении входных значений.

#### Проблемы производительности Immutable.js

Автор Immutable.js Ли Байрон в Твиттере [явно советует избегать `toJS`, когда производительность является проблемой](https://twitter.com/leeb/status/746733697093668864?lang=en)

> Совет от Perf для #immutablejs: избегайте .toJS() .toObject() и .toArray() всех медленных операций полного копирования, которые делают структурное совместное использование бесполезным.

Есть несколько других проблем с производительностью, которые следует учитывать при использовании Immutable.js - см. список ссылок в конце этой страницы для получения дополнительной информации.

## Поведение и ошибки

### `mapStateToProps` не будет запускаться, если состояние хранилища такое же

Компонент оболочки, сгенерированный `connect`, подписывается на хранилище Redux. Каждый раз, когда отправляется действие, оно вызывает `store.getState()` и проверяет, есть ли `lastState === currentState`. Если два значения состояния идентичны по ссылке, то он повторно _не_ запускает вашу функцию `mapStateToProps`, поскольку предполагает, что остальная часть состояния хранилища также не изменилась.

Утилита Redux `combineReducers` пытается оптимизировать для этого. Если ни один из редьюсеров срезов не вернул новое значение, то `combineReducers` вернет старый объект состояния вместо нового. Это означает, что мутация в редьюсере может привести к тому, что объект корневого состояния не будет обновлен, и, следовательно, пользовательский интерфейс не будет повторно отображаться.

### Количество заявленных аргументов влияет на поведение

С помощью только `(state)` функция запускается всякий раз, когда объект состояния корневого хранилища отличается. С `(state, ownProps)` он запускается каждый раз, когда состояние хранилища отличается, а ТАКЖЕ всякий раз, когда изменились свойства оболочки.

Это означает, что **вам не следует добавлять аргумент `ownProps`, если он вам не нужен**, иначе ваша функция `mapStateToProps` будет запускаться чаще, чем нужно.

Есть несколько крайних случаев вокруг этого поведения. **Количество обязательных аргументов определяет, получит ли `mapStateToProps` `ownProps`**.

Если формальное определение функции содержит один обязательный параметр, `mapStateToProps` _не_ получит `ownProps`:

```js
function mapStateToProps(state) {
  console.log(state) // state
  console.log(arguments[1]) // undefined
}
const mapStateToProps = (state, ownProps = {}) => {
  console.log(state) // state
  console.log(ownProps) // {}
}
```

Он _получит_ `ownProps`, когда формальное определение функции содержит ноль или два обязательных параметра:

```js
function mapStateToProps(state, ownProps) {
  console.log(state) // state
  console.log(ownProps) // ownProps
}

function mapStateToProps() {
  console.log(arguments[0]) // state
  console.log(arguments[1]) // ownProps
}

function mapStateToProps(...args) {
  console.log(args[0]) // state
  console.log(args[1]) // ownProps
}
```

## Ссылки

**Учебники**

- [Practical Redux Series, Part 6: Connected Lists, Forms, and Performance](https://blog.isquaredsoftware.com/2017/01/practical-redux-part-6-connected-lists-forms-and-performance/)
- [Idiomatic Redux: Using Reselect Selectors for Encapsulation and Performance](https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/)

**Performance**

- [Lee Byron's Tweet Suggesting to avoid `toJS`, `toArray` and `toObject` for Performance](https://twitter.com/leeb/status/746733697093668864)
- [Improving React and Redux performance with Reselect](https://blog.rangle.io/react-and-redux-performance-with-reselect/)
- [Immutable data performance links](https://github.com/markerikson/react-redux-links/blob/master/react-performance.md#immutable-data)

**Q&A**

- [Why Is My Component Re-Rendering Too Often?](https://redux.js.org/faq/react-redux#why-is-my-component-re-rendering-too-often)
- [Why isn't my component re-rendering, or my mapStateToProps running](https://redux.js.org/faq/react-redux#why-isnt-my-component-re-rendering-or-my-mapstatetoprops-running)
- [How can I speed up my mapStateToProps?](https://redux.js.org/faq/react-redux#how-can-i-speed-up-my-mapstatetoprops)
- [Should I only connect my top component, or can I connect multiple components in my tree?](https://redux.js.org/faq/react-redux#should-i-only-connect-my-top-component-or-can-i-connect-multiple-components-in-my-tree)
